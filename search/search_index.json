{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ACKNOWLEDGEMENTS Special thanks to Craig Brandt and other colleagues from the Red Hat team for preparing the sample Ansible Playbooks for the Technical Preview of IBM watsonx Code Assistant for Red Hat Ansible Lightspeed . Generally speaking, Generative AI is the talk of the town in 2023 \u2014 and likely will remain so for years to come. What began to simmer in the early 2020s as excitement within academic and technology community around around transformers and language models has today exploded into a firestorm of interest and investment across nearly every industry, institution, and government. For the first time at scale, everyday consumers have access to artificial intelligence on their phones and through their web browsers. Likewise, enterprise and business leaders no longer view AI as a topic of interest, but as a critical imperative to success in the future economy. \"Foundation Models\"\u2014 a term coined by Stanford University \u2014are built using a specific kind of neural network architecture, called a Transformer. The Transformer helps the Foundation Model understand unlabeled data and turn an input into an output. The most consequential manifestation of this technology so far is what we know today as \"Generative AI.\" So what is \"Generative AI\"? The vast topic refers to a subset of AI techniques and methodologies that are designed to generate new content \u2014 in other words, AI applied towards the creation of novel contents in the form of images, text, voice, or even code. This sharply differs from the goals of more \"traditional\" AI models of the past, which have primarily been focused on the analysis and classification (labeling) of information. Historically, these early pioneering techniques of AI models have progressed from simple probabilistic models into increasingly sophisticated systems, building upon concepts like neural networks and deep learning techniques. Today, technologies like Generative AI showcase not only the ability to analysis, but tremendous capacity for creation. Even the creation of application code and automation tasks. The advent of Foundation Models and Generative AI, given their remarkable performance and extensibility to a wide range of tasks, is bringing an inflection point in AI. Recognizing the significance of the moment, IBM enterprise clients are actively evaluating and seeking to incorporate foundation models into critical business workflows for applications involving generation, summarization, classification, and so many other use cases. The notion of automating the generation of Ansible Playbook code with AI stems from the challenges and bottlenecks often faced by developers tasked with traditional, manual creation of Playbooks. These individuals must craft precise, error-free Playbooks which are potentially automation jobs across vast collections of assets or hardware. One of the benefits of automation is being able to perform such tasks at-scale; conversely, this also poses one of the greatest risks of automation \u2014 that when things fail, they can fail rapidly and across vast swathes of IT estate. It should come as no surprise, then, that authoring Playbooks often demands technical expertise and a deep understanding of the targeted systems and services which Ansible is to automate. If you recollect the founding philosophies of Red Hat Ansible\u2014 human-readable automation jobs, the democratization of automation to non-technical audiences \u2014you might think the practicalities of manually creating Ansible Playbooks is antithetical to Ansible's potential. And you would be correct in that logic. Generative AI, especially models like GPT, have recently demonstrated proficiency in creating syntactically correct and contextually relevant application code in a variety of programming languages. If trained on a large dataset of Ansible Playbooks, Generative AI models can be fine-tuned to understand the nuances of Playbook syntax and structure. An enterprise organization with dozens or hundreds of Playbooks within their IT estate today would have a rich corpus of training data on-hand that could be used to fine-tune AI models that are tailored to the automation needs and programming style/standards of that particular company. As we will see later, productized versions of the Generative AI models can provide a natural language prompt or a specific description of the desired task to users \u2014 who in turn can utilize these models for generating the necessary Playbook code. For example, a user might describe a desired system state in plain language (\"I want a Playbook to install and start the Apache web server\") and the model would generate the appropriate Ansible tasks for a Playbook. All of this achieved without physically writing code or requiring much programming expertise. Not only does this speed up the automation process by cutting the time needed to author Playbooks, but it also democratizes access to automation in general. Even those within the company with limited Ansible or programming expertise will be able produce effective Playbooks. There are plenty of caveats of course, and thorough validation and testing will be needed to safeguard against the at-scale automation disaster scenarios that were mentioned previously. However, the productivity gains and broadening of skillsets within an organization can be tremendous. And as a whole, Generative AI brings the original goals of Red Hat Ansible Automation Platform (the democratization of automation for everything) that much closer to a reality. The material covered in this Level 3 coursework will prepare IBM and business partner technical sellers with the skills necessary to demonstrate Ansible Playbook task creation using the generative AI capabilities of IBM watsonx Code Assistant for Red Hat Ansible Lightspeed . A client demo-ready Technical Preview is available free of charge through the open source community, which you will make use of as well for this hands-on learning via extensions in VS Code (Visual Studio Code) on your local machine. This service uses, among other data, roles and collections that are available through the Red Hat community website, Ansible Galaxy . The documentation within this Level 3 lab will cover how to use set up Code VS on a local machine (macOS or Windows) with an extension for IBM watsonx Code Assistant for Red Hat Ansible Lightspeed . You will then leverage the generative AI content recommendations for creating a variety of Ansible Playbooks for automating cloud-based and infrastructure-based automation tasks, such as: Install and configure Cockpit for Ansible Preparing an AWS and Azure cloud environment Provisioning an AWS EC2 instance Provisioning an Azure virtual machine (VM) Run a Podman 'pgadmin' container Deploy and start a PostgreSQL database server These short demonstrations will go beyond simply giving you hands-on experience with Ansible Lightspeed's generative AI capabilities for Ansible Playbook task creation. In-depth explanations accomanying the Playbooks will also explain: The integrations that Ansible Lightspeed and IBM watsonx provide in terms of content tooling How Ansible Lightspeed natural language prompts, as well as the Ansible Playbook contents, to create contextually-aware code suggestions for Ansible Tasks Pre-processing and post-processing capabilities that refine the generative AI suggestions into syntactically correct code (adherent to best practices) How Ansible Lightspeed provides \"explainability\" and source content matching attribution for all AI-generated content Ahead, we will cover the pre-requisites for getting started with the hands-on material, as well as outline the evaluation criteria for IBM technical sellers and business partners.","title":"Introduction"},{"location":"#_1","text":"","title":""},{"location":"#generally-speaking-generative-ai-is-the-talk-of-the-town-in-2023-and-likely-will-remain-so-for-years-to-come","text":"What began to simmer in the early 2020s as excitement within academic and technology community around around transformers and language models has today exploded into a firestorm of interest and investment across nearly every industry, institution, and government. For the first time at scale, everyday consumers have access to artificial intelligence on their phones and through their web browsers. Likewise, enterprise and business leaders no longer view AI as a topic of interest, but as a critical imperative to success in the future economy. \"Foundation Models\"\u2014 a term coined by Stanford University \u2014are built using a specific kind of neural network architecture, called a Transformer. The Transformer helps the Foundation Model understand unlabeled data and turn an input into an output. The most consequential manifestation of this technology so far is what we know today as \"Generative AI.\" So what is \"Generative AI\"? The vast topic refers to a subset of AI techniques and methodologies that are designed to generate new content \u2014 in other words, AI applied towards the creation of novel contents in the form of images, text, voice, or even code. This sharply differs from the goals of more \"traditional\" AI models of the past, which have primarily been focused on the analysis and classification (labeling) of information. Historically, these early pioneering techniques of AI models have progressed from simple probabilistic models into increasingly sophisticated systems, building upon concepts like neural networks and deep learning techniques. Today, technologies like Generative AI showcase not only the ability to analysis, but tremendous capacity for creation. Even the creation of application code and automation tasks. The advent of Foundation Models and Generative AI, given their remarkable performance and extensibility to a wide range of tasks, is bringing an inflection point in AI. Recognizing the significance of the moment, IBM enterprise clients are actively evaluating and seeking to incorporate foundation models into critical business workflows for applications involving generation, summarization, classification, and so many other use cases.","title":"Generally speaking, Generative AI is the talk of the town in 2023 \u2014 and likely will remain so for years to come."},{"location":"#_2","text":"","title":""},{"location":"#the-notion-of-automating-the-generation-of-ansible-playbook-code-with-ai-stems-from-the-challenges-and-bottlenecks-often-faced-by-developers-tasked-with-traditional-manual-creation-of-playbooks","text":"These individuals must craft precise, error-free Playbooks which are potentially automation jobs across vast collections of assets or hardware. One of the benefits of automation is being able to perform such tasks at-scale; conversely, this also poses one of the greatest risks of automation \u2014 that when things fail, they can fail rapidly and across vast swathes of IT estate. It should come as no surprise, then, that authoring Playbooks often demands technical expertise and a deep understanding of the targeted systems and services which Ansible is to automate. If you recollect the founding philosophies of Red Hat Ansible\u2014 human-readable automation jobs, the democratization of automation to non-technical audiences \u2014you might think the practicalities of manually creating Ansible Playbooks is antithetical to Ansible's potential. And you would be correct in that logic. Generative AI, especially models like GPT, have recently demonstrated proficiency in creating syntactically correct and contextually relevant application code in a variety of programming languages. If trained on a large dataset of Ansible Playbooks, Generative AI models can be fine-tuned to understand the nuances of Playbook syntax and structure. An enterprise organization with dozens or hundreds of Playbooks within their IT estate today would have a rich corpus of training data on-hand that could be used to fine-tune AI models that are tailored to the automation needs and programming style/standards of that particular company. As we will see later, productized versions of the Generative AI models can provide a natural language prompt or a specific description of the desired task to users \u2014 who in turn can utilize these models for generating the necessary Playbook code. For example, a user might describe a desired system state in plain language (\"I want a Playbook to install and start the Apache web server\") and the model would generate the appropriate Ansible tasks for a Playbook. All of this achieved without physically writing code or requiring much programming expertise. Not only does this speed up the automation process by cutting the time needed to author Playbooks, but it also democratizes access to automation in general. Even those within the company with limited Ansible or programming expertise will be able produce effective Playbooks. There are plenty of caveats of course, and thorough validation and testing will be needed to safeguard against the at-scale automation disaster scenarios that were mentioned previously. However, the productivity gains and broadening of skillsets within an organization can be tremendous. And as a whole, Generative AI brings the original goals of Red Hat Ansible Automation Platform (the democratization of automation for everything) that much closer to a reality.","title":"The notion of automating the generation of Ansible Playbook code with AI stems from the challenges and bottlenecks often faced by developers tasked with traditional, manual creation of Playbooks."},{"location":"#_3","text":"","title":""},{"location":"#the-material-covered-in-this-level-3-coursework-will-prepare-ibm-and-business-partner-technical-sellers-with-the-skills-necessary-to-demonstrate-ansible-playbook-task-creation-using-the-generative-ai-capabilities-of-ibm-watsonx-code-assistant-for-red-hat-ansible-lightspeed","text":"A client demo-ready Technical Preview is available free of charge through the open source community, which you will make use of as well for this hands-on learning via extensions in VS Code (Visual Studio Code) on your local machine. This service uses, among other data, roles and collections that are available through the Red Hat community website, Ansible Galaxy . The documentation within this Level 3 lab will cover how to use set up Code VS on a local machine (macOS or Windows) with an extension for IBM watsonx Code Assistant for Red Hat Ansible Lightspeed . You will then leverage the generative AI content recommendations for creating a variety of Ansible Playbooks for automating cloud-based and infrastructure-based automation tasks, such as: Install and configure Cockpit for Ansible Preparing an AWS and Azure cloud environment Provisioning an AWS EC2 instance Provisioning an Azure virtual machine (VM) Run a Podman 'pgadmin' container Deploy and start a PostgreSQL database server These short demonstrations will go beyond simply giving you hands-on experience with Ansible Lightspeed's generative AI capabilities for Ansible Playbook task creation. In-depth explanations accomanying the Playbooks will also explain: The integrations that Ansible Lightspeed and IBM watsonx provide in terms of content tooling How Ansible Lightspeed natural language prompts, as well as the Ansible Playbook contents, to create contextually-aware code suggestions for Ansible Tasks Pre-processing and post-processing capabilities that refine the generative AI suggestions into syntactically correct code (adherent to best practices) How Ansible Lightspeed provides \"explainability\" and source content matching attribution for all AI-generated content Ahead, we will cover the pre-requisites for getting started with the hands-on material, as well as outline the evaluation criteria for IBM technical sellers and business partners.","title":"The material covered in this Level 3 coursework will prepare IBM and business partner technical sellers with the skills necessary to demonstrate Ansible Playbook task creation using the generative AI capabilities of IBM watsonx Code Assistant for Red Hat Ansible Lightspeed."},{"location":"Part%201/01-Prerequisites/","text":"Prerequisites and Setup Before getting started, you must install Visual Studio Code (commonly referred to as VS Code ) on your local machine. VS Code is a code editor built on open source technology, free to use, and published by Microsoft. Distributions are available for every major operating system, including Windows and macOS. Download : https://code.visualstudio.com Select the latest \"stable\" release availabe for your machine's operating system. Follow along with the installer wizard steps and continue after VS Code is successfully running on your local machine. Open the VS Code app and locate the sidebar along the left-side of the interface. Click the Extensions icon as shown to open the marketplace of Microsoft services and open source technologies that can be integrated with VS Code. At the top of the Extensions panel is a search bar. Search here for Ansible . Locate from the results the Ansible service published by Red Hat . Click the blue Install icon located to the right. DEPRECATED VERSION You may ignore the deprecated version of \"Ansible language support\" that was previously published by Tomasz Maciazek. The only official (and installable) Ansible extension is the one published by Red Hat's verified account. Installation of the Ansible extension for VS Code should only take a moment. When it's ready, clear the search bar filter and look for Ansible under the \"Installed\" services under the Extensions panel. Click the mechanical \"cog\" icon (as shown), located on the right side of the Ansible service tile. From the dropdown list of options, click Extension Settings . A settings panel for the Ansible extension will fill the screen. From the top-left corner of the interface, look for a switch to toggle between User and Workspace . Select the Workspace option. Scroll down the list of settings until you locate the fields Ansible > Lightspeed and Ansible > Lightspeed > Suggestions . By default, these will be disabled. Click the checkmark icons to the left of BOTH entries to ENABLE IBM watsonx Code Assistant for Red Hat Ansible Lightspeed Tech Preview features within the VS Code environment. The settings will automatically be applied without needing to confirm or \"save\" manually. Close the Settings tab using the X icon along the top of the taskbar to proceed. Next, you will need to register for an account with GitHub . If you already have an account registered with GitHub, you may skip ahead to Step 9. Register : https://github.com GitHub, Inc. is a platform and cloud-based service for software development and version control using Git , allowing developers to store and manage their code. Like VS Code, it is also owned by Microsoft Corporation. With a registered GitHub account, you are now ready to add the GitHub extension for VS Code to your local machine. This will follow a very similar process to what you performed for installing Ansible. Select the Extensions tab from the left-side of the VS Code interface and search for GitHub Pull Requests . Click the Install icon to add the Extension to your VS Code environment. Integration with VS Code should only take a moment to complete. With the GitHub extension now available within VS Code, you must authorize and link the service to your personal GitHub account. Notice that in the left-hand interface of the VS Code environment, there are now icons (further down from the Extensions tab) for Ansible and GitHub . Click the GitHub tab. In the top-left of the interface, locate and click the blue Sign In button (as shown below). A web browser tab will open, directing you to log in to GitHub using the personal account you registered in Step 8. After authenticating, you will be asked to Authorize Visual-Studio-Code for access to your GitHub account. Do so by clicking the green icon and accepting any prompts. VS Code will ask \"Allow an extension to open this URI?\" to which you should select Open (and toggle \"Don't ask again for this extension\" if you would rather not see future prompts). Once connected to your personal GitHub account, the left side of the VS Code interface will populate with any published code repositories (\"repos\") that are already associated with the account. If you have only registered with GitHub for this lab, this section may appear as empty. To begin experimenting with IBM watsonx Code Assistant for Red Hat Ansible Lightspeed's generative AI capabilities, we first need access to some Ansible Playbooks to generate Tasks with. Playbooks have already been prepared ahead of time for the Ansible Lightspeed Tech Preview, which we will make use of here. A \"pull\" request in GitHub is essentially a request to replicate code from the cloud-hosted repository into the local (VS Code and local machine) environment. To perform a pull request with VS Code, do either of the following actions (depending on your operating system): Windows : With the GitHub Extension tab open in VS Code, press CTRL + Shift + P to open an executable console at the top of VS Code. macOS : With the GitHub Extension tab open in VS Code, press COMMAND + Shift + P to open an executable console at the top of VS Code. The remainder of the instructions are the same for all operating systems. Enter into the terminal prompt the following instruction: git:clone On your keyboard, hit Return/Enter to confirm. Now you must specify the public repository from which to clone the data. Copy and paste the following URL into the terminal prompt: Pull Request URL : https://github.com/craig-br/lightspeed-demos.git On your keyboard, hit Return/Enter to confirm. You will be asked to select (using your local machine's file browser) the destination for where the cloned data will be saved locally. Select a directory (Documents, Desktop, or your preference) and then confirm by clicking Select as Repository Destination to kick off the replication from GitHub to your local machine. A prompt will appear asking Would you like to open the cloned repository, or add it to the current workspace? to which you should click Open . You will be asked Do you trust the authors of the files in this folder? to which you should click Yes, I trust the authors . The replication of Ansible Playbooks to your local machine from GitHub is now complete. You can inspect the contents of the repository using the Explorer tab (the first icon in the left-hand navigator), as shown in the following screenshot. LOCAL REPLICAS The replicated/cloned GitHub files are a local replica, meaning that you may safely edit and change the contents of this folder on your local machine without any impact to the master copy on GitHub. Have fun and experiment! Next, you'll need to activate your Ansible Lightspeed Tech Preview for the Ansible extension inside VS Code. This will follow a similar process to how you previously authorized the GitHub extension. Click the Ansible icon from the left-hand interface of the VS Code environment (look for the large \"A\" icon). A panel will open displaying details about Ansible Lightspeed Login . Click the blue Connect button to launch the authorization tool. A prompt will appear stating that The extension Ansible wants to sign in using Ansible Lightspeed to which you should click Allow . You will then be asked about opening an external website, to which you should reply Open . Your web browser will then load to a page asking you to login in using either Red Hat or GitHub. Click the Log in with GitHub option. OUTDATED PRODUCT NAMES The branding displayed on this page is an outdated name for the offering before reaching General Availability (GA) status. The correct name is IBM watsonx Code Assistant for Red Hat Ansible Lightspeed . Supply your GitHub account name and password (Step 8). If you have already authenticated using the GitHub extension for VS Code, it may bypass that require entirely. After logging in, you will be asked to Authorize Ansible Lightspeed for VS Code to which you should click Authorize . A prompt will attempt inside VS Code asking Allow an extension to open this URI? to which you should click Open . In the bottom-right corner of the VS Code environment, a pop-up will appear with a Welcome back message. Just below this message, along the very bottom-right hand corner of the VS Code environment, a tile labelled Ansible will also have appeared. This indicates that Ansible (and Ansible Lightspeed) are now activated for this particular workspace. PYTHON LIBRARY The VS Code environment also requires that Python 3.9.13 (or higher) be activated as part of the workspace. Look for a Python tile adjacent to the Ansible tile along the bottom-right corner of the VS Code interface. If it is not set, click the tile and select Python 3.9.13 (or higher). Well done. Your VS Code environment is now fully configured and ready for experimentation using generative AI techniques. In the following section, we will review the evaluation criteria for how IBM technical sellers and business partners receive accreditation for completing the Level 3 material.","title":"Setup"},{"location":"Part%201/01-Prerequisites/#prerequisites-and-setup","text":"Before getting started, you must install Visual Studio Code (commonly referred to as VS Code ) on your local machine. VS Code is a code editor built on open source technology, free to use, and published by Microsoft. Distributions are available for every major operating system, including Windows and macOS. Download : https://code.visualstudio.com Select the latest \"stable\" release availabe for your machine's operating system. Follow along with the installer wizard steps and continue after VS Code is successfully running on your local machine. Open the VS Code app and locate the sidebar along the left-side of the interface. Click the Extensions icon as shown to open the marketplace of Microsoft services and open source technologies that can be integrated with VS Code. At the top of the Extensions panel is a search bar. Search here for Ansible . Locate from the results the Ansible service published by Red Hat . Click the blue Install icon located to the right. DEPRECATED VERSION You may ignore the deprecated version of \"Ansible language support\" that was previously published by Tomasz Maciazek. The only official (and installable) Ansible extension is the one published by Red Hat's verified account. Installation of the Ansible extension for VS Code should only take a moment. When it's ready, clear the search bar filter and look for Ansible under the \"Installed\" services under the Extensions panel. Click the mechanical \"cog\" icon (as shown), located on the right side of the Ansible service tile. From the dropdown list of options, click Extension Settings . A settings panel for the Ansible extension will fill the screen. From the top-left corner of the interface, look for a switch to toggle between User and Workspace . Select the Workspace option. Scroll down the list of settings until you locate the fields Ansible > Lightspeed and Ansible > Lightspeed > Suggestions . By default, these will be disabled. Click the checkmark icons to the left of BOTH entries to ENABLE IBM watsonx Code Assistant for Red Hat Ansible Lightspeed Tech Preview features within the VS Code environment. The settings will automatically be applied without needing to confirm or \"save\" manually. Close the Settings tab using the X icon along the top of the taskbar to proceed. Next, you will need to register for an account with GitHub . If you already have an account registered with GitHub, you may skip ahead to Step 9. Register : https://github.com GitHub, Inc. is a platform and cloud-based service for software development and version control using Git , allowing developers to store and manage their code. Like VS Code, it is also owned by Microsoft Corporation. With a registered GitHub account, you are now ready to add the GitHub extension for VS Code to your local machine. This will follow a very similar process to what you performed for installing Ansible. Select the Extensions tab from the left-side of the VS Code interface and search for GitHub Pull Requests . Click the Install icon to add the Extension to your VS Code environment. Integration with VS Code should only take a moment to complete. With the GitHub extension now available within VS Code, you must authorize and link the service to your personal GitHub account. Notice that in the left-hand interface of the VS Code environment, there are now icons (further down from the Extensions tab) for Ansible and GitHub . Click the GitHub tab. In the top-left of the interface, locate and click the blue Sign In button (as shown below). A web browser tab will open, directing you to log in to GitHub using the personal account you registered in Step 8. After authenticating, you will be asked to Authorize Visual-Studio-Code for access to your GitHub account. Do so by clicking the green icon and accepting any prompts. VS Code will ask \"Allow an extension to open this URI?\" to which you should select Open (and toggle \"Don't ask again for this extension\" if you would rather not see future prompts). Once connected to your personal GitHub account, the left side of the VS Code interface will populate with any published code repositories (\"repos\") that are already associated with the account. If you have only registered with GitHub for this lab, this section may appear as empty. To begin experimenting with IBM watsonx Code Assistant for Red Hat Ansible Lightspeed's generative AI capabilities, we first need access to some Ansible Playbooks to generate Tasks with. Playbooks have already been prepared ahead of time for the Ansible Lightspeed Tech Preview, which we will make use of here. A \"pull\" request in GitHub is essentially a request to replicate code from the cloud-hosted repository into the local (VS Code and local machine) environment. To perform a pull request with VS Code, do either of the following actions (depending on your operating system): Windows : With the GitHub Extension tab open in VS Code, press CTRL + Shift + P to open an executable console at the top of VS Code. macOS : With the GitHub Extension tab open in VS Code, press COMMAND + Shift + P to open an executable console at the top of VS Code. The remainder of the instructions are the same for all operating systems. Enter into the terminal prompt the following instruction: git:clone On your keyboard, hit Return/Enter to confirm. Now you must specify the public repository from which to clone the data. Copy and paste the following URL into the terminal prompt: Pull Request URL : https://github.com/craig-br/lightspeed-demos.git On your keyboard, hit Return/Enter to confirm. You will be asked to select (using your local machine's file browser) the destination for where the cloned data will be saved locally. Select a directory (Documents, Desktop, or your preference) and then confirm by clicking Select as Repository Destination to kick off the replication from GitHub to your local machine. A prompt will appear asking Would you like to open the cloned repository, or add it to the current workspace? to which you should click Open . You will be asked Do you trust the authors of the files in this folder? to which you should click Yes, I trust the authors . The replication of Ansible Playbooks to your local machine from GitHub is now complete. You can inspect the contents of the repository using the Explorer tab (the first icon in the left-hand navigator), as shown in the following screenshot. LOCAL REPLICAS The replicated/cloned GitHub files are a local replica, meaning that you may safely edit and change the contents of this folder on your local machine without any impact to the master copy on GitHub. Have fun and experiment! Next, you'll need to activate your Ansible Lightspeed Tech Preview for the Ansible extension inside VS Code. This will follow a similar process to how you previously authorized the GitHub extension. Click the Ansible icon from the left-hand interface of the VS Code environment (look for the large \"A\" icon). A panel will open displaying details about Ansible Lightspeed Login . Click the blue Connect button to launch the authorization tool. A prompt will appear stating that The extension Ansible wants to sign in using Ansible Lightspeed to which you should click Allow . You will then be asked about opening an external website, to which you should reply Open . Your web browser will then load to a page asking you to login in using either Red Hat or GitHub. Click the Log in with GitHub option. OUTDATED PRODUCT NAMES The branding displayed on this page is an outdated name for the offering before reaching General Availability (GA) status. The correct name is IBM watsonx Code Assistant for Red Hat Ansible Lightspeed . Supply your GitHub account name and password (Step 8). If you have already authenticated using the GitHub extension for VS Code, it may bypass that require entirely. After logging in, you will be asked to Authorize Ansible Lightspeed for VS Code to which you should click Authorize . A prompt will attempt inside VS Code asking Allow an extension to open this URI? to which you should click Open . In the bottom-right corner of the VS Code environment, a pop-up will appear with a Welcome back message. Just below this message, along the very bottom-right hand corner of the VS Code environment, a tile labelled Ansible will also have appeared. This indicates that Ansible (and Ansible Lightspeed) are now activated for this particular workspace. PYTHON LIBRARY The VS Code environment also requires that Python 3.9.13 (or higher) be activated as part of the workspace. Look for a Python tile adjacent to the Ansible tile along the bottom-right corner of the VS Code interface. If it is not set, click the tile and select Python 3.9.13 (or higher). Well done. Your VS Code environment is now fully configured and ready for experimentation using generative AI techniques. In the following section, we will review the evaluation criteria for how IBM technical sellers and business partners receive accreditation for completing the Level 3 material.","title":"Prerequisites and Setup"},{"location":"Part%201/02-Evaluation-Criteria/","text":"Evaluation Criteria for IBM and Business Partner Technical Sellers","title":"Evaluation Criteria"},{"location":"Part%201/02-Evaluation-Criteria/#evaluation-criteria-for-ibm-and-business-partner-technical-sellers","text":"","title":"Evaluation Criteria for IBM and Business Partner Technical Sellers"},{"location":"Part%201/03-Generating-Code/","text":"Hands-on: Generating Playbook Tasks with IBM watsonx Code Assistant for Ansible Lightspeed Playbook #1 # ANSIBLE PLAYBOOK - Install an nginx webserver and launch the service # AUTHOR \u2014 Deepak C. Shetty (deepakcshetty@in.ibm.com) # # Module makes use of the 'yum' package manager, as well as the # 'template' and 'service' Ansible modulesm for installing the # nginx application stack with a customized index.html file. - name: Install nginx hosts: webserver tasks: - name: Add epel-release repo yum: name: epel-release state: present - name: Install nginx yum: name: nginx state: present - name: Insert index page template: src: index.html dest: /usr/share/nginx/html/index.html - name: Start nginx service service: name: nginx state: started Playbook #2 # ANSIBLE PLAYBOOK \u2014 Invoke 2 modules to automatically update 2 types of servers. # AUTHOR: Red Hat @ https://www.redhat.com/en/topics/automation/what-is-an-ansible-playbook --- # Task 1 - name: Update web servers hosts: webservers become: true tasks: - name: Ensure apache is at the latest version ansible.builtin.yum: name: httpd state: latest - name: Write the apache config file ansible.builtin.template: src: /srv/httpd.j2 dest: /etc/httpd.config mode: \"0644\" # Task 2 - name: Update db servers hosts: databases become: true tasks: - name: Ensure postgresql is at the latest version ansible.builtin.yum: name: postgresql state: latest - name: Ensure that postgresql is started ansible.builtin.service: name: postgresql state: started","title":"Generating Code"},{"location":"Part%201/03-Generating-Code/#hands-on-generating-playbook-tasks-with-ibm-watsonx-code-assistant-for-ansible-lightspeed","text":"Playbook #1 # ANSIBLE PLAYBOOK - Install an nginx webserver and launch the service # AUTHOR \u2014 Deepak C. Shetty (deepakcshetty@in.ibm.com) # # Module makes use of the 'yum' package manager, as well as the # 'template' and 'service' Ansible modulesm for installing the # nginx application stack with a customized index.html file. - name: Install nginx hosts: webserver tasks: - name: Add epel-release repo yum: name: epel-release state: present - name: Install nginx yum: name: nginx state: present - name: Insert index page template: src: index.html dest: /usr/share/nginx/html/index.html - name: Start nginx service service: name: nginx state: started Playbook #2 # ANSIBLE PLAYBOOK \u2014 Invoke 2 modules to automatically update 2 types of servers. # AUTHOR: Red Hat @ https://www.redhat.com/en/topics/automation/what-is-an-ansible-playbook --- # Task 1 - name: Update web servers hosts: webservers become: true tasks: - name: Ensure apache is at the latest version ansible.builtin.yum: name: httpd state: latest - name: Write the apache config file ansible.builtin.template: src: /srv/httpd.j2 dest: /etc/httpd.config mode: \"0644\" # Task 2 - name: Update db servers hosts: databases become: true tasks: - name: Ensure postgresql is at the latest version ansible.builtin.yum: name: postgresql state: latest - name: Ensure that postgresql is started ansible.builtin.service: name: postgresql state: started","title":"Hands-on: Generating Playbook Tasks with IBM watsonx Code Assistant for Ansible Lightspeed"},{"location":"Part%201/04-Custom-Playbooks/","text":"Hands-on: Generating Playbook Tasks with IBM watsonx Code Assistant for Ansible Lightspeed CUSTOM PLAYBOOK #1 - Install an nginx webserver and launch the service ``` yaml ANSIBLE PLAYBOOK - Install an nginx webserver and launch the service AUTHOR \u2014 Deepak C. Shetty (deepakcshetty@in.ibm.com) Module makes use of the 'yum' package manager, as well as the 'template' and 'service' Ansible modulesm for installing the nginx application stack with a customized index.html file. name: Install nginx hosts: webserver tasks: - name: Add epel-release repo yum: name: epel-release state: present - name: Install nginx yum: name: nginx state: present - name: Insert index page template: src: index.html dest: /usr/share/nginx/html/index.html - name: Start nginx service service: name: nginx state: started ``` Playbook #1 # ANSIBLE PLAYBOOK - Install an nginx webserver and launch the service # AUTHOR \u2014 Deepak C. Shetty (deepakcshetty@in.ibm.com) # # Module makes use of the 'yum' package manager, as well as the # 'template' and 'service' Ansible modulesm for installing the # nginx application stack with a customized index.html file. - name: Install nginx hosts: webserver tasks: - name: Add epel-release repo yum: name: epel-release state: present - name: Install nginx yum: name: nginx state: present - name: Insert index page template: src: index.html dest: /usr/share/nginx/html/index.html - name: Start nginx service service: name: nginx state: started Playbook #2 # ANSIBLE PLAYBOOK \u2014 Invoke 2 modules to automatically update 2 types of servers. # AUTHOR: Red Hat @ https://www.redhat.com/en/topics/automation/what-is-an-ansible-playbook --- # Task 1 - name: Update web servers hosts: webservers become: true tasks: - name: Ensure apache is at the latest version ansible.builtin.yum: name: httpd state: latest - name: Write the apache config file ansible.builtin.template: src: /srv/httpd.j2 dest: /etc/httpd.config mode: \"0644\" # Task 2 - name: Update db servers hosts: databases become: true tasks: - name: Ensure postgresql is at the latest version ansible.builtin.yum: name: postgresql state: latest - name: Ensure that postgresql is started ansible.builtin.service: name: postgresql state: started Precision is key for natural language prompts Consider the following Task, which prompts Ansible to create (\"write\") a configuration file for an Apache webserver: - name: Write the apache config file Two tabs are presented below. The first AI-Generated Code tab shows the output from running Ansible Lightspeed's generative AI capabilities on an unmodified version of this Playbook. The second Solution Code tab shows the expected Task code that was written (and commented out) by a human to perform the same task. In theory, the suggested code should be as good\u2014 or even superior to \u2014the manually-written solution code. Let's examine that theory in practice: AI-Generated Code Solution Code - name : Write the apache config file ansible.builtin.copy : content : \"{{ _content_ }}\" dest : /etc/httpd/conf.d/000-default.conf - name : Write the apache config file ansible.builtin.template : src : /srv/httpd.j2 dest : /etc/httpd.config mode : \"0644\" As you can see, the AI-Generated code in the first tab misses the mark in a few areas. In fact, it appears to have misunderstood the task in quite a few ways. There is no corresponding value to _content_ that can be located within the Ansible Playbook, at least not any which you (the author) have defined ahead of time. Such a result is unexpected and does not match the intention of writing an Apache configuration file to standards/best practices. Similarly, the destination has been inferred differently and the access permissions that should have been applied to the config file (again - according to Red Hat best practices) is missing altogether. WHY THE UNEXPECTED RESULTS? Something has gone wrong \u2014 is Ansible Lightspeed at fault? The root cause of the error, in fact, is human . The precision with which the Playbook author describes the automation Task in natural language will determine the accuracy and effectiveness of Ansible Lightspeed's generated code suggestions. In general, the more ambiguous the Task description given, the greater the likelihood that Ansible Lightspeed will misinterpret the author's intent and suggest unwanted Ansible automation jobs. To help disambiguate our intention, we as Playbook authors can use more precise natural language terms and descriptions. Let's slightly modify the Task description (within the - name: line) and observe how the AI-generated code suggestions are modified as a result: AI-Generated Code Solution Code - name : Write the apache config file with mode 0644 ansible.builtin.copy : content : \"{{ _content_ }}\" dest : /etc/httpd/conf.d/000-default.conf - name : Write the apache config file ansible.builtin.copy : content : \"{{ _content_ }}\" dest : /etc/httpd/conf.d/000-default.conf","title":"Custom Playbooks"},{"location":"Part%201/04-Custom-Playbooks/#hands-on-generating-playbook-tasks-with-ibm-watsonx-code-assistant-for-ansible-lightspeed","text":"CUSTOM PLAYBOOK #1 - Install an nginx webserver and launch the service ``` yaml","title":"Hands-on: Generating Playbook Tasks with IBM watsonx Code Assistant for Ansible Lightspeed"},{"location":"Part%201/04-Custom-Playbooks/#ansible-playbook-install-an-nginx-webserver-and-launch-the-service","text":"","title":"ANSIBLE PLAYBOOK - Install an nginx webserver and launch the service"},{"location":"Part%201/04-Custom-Playbooks/#author-deepak-c-shetty-deepakcshettyinibmcom","text":"","title":"AUTHOR \u2014 Deepak C. Shetty (deepakcshetty@in.ibm.com)"},{"location":"Part%201/04-Custom-Playbooks/#_1","text":"","title":""},{"location":"Part%201/04-Custom-Playbooks/#module-makes-use-of-the-yum-package-manager-as-well-as-the","text":"","title":"Module makes use of the 'yum' package manager, as well as the"},{"location":"Part%201/04-Custom-Playbooks/#template-and-service-ansible-modulesm-for-installing-the","text":"","title":"'template' and 'service' Ansible modulesm for installing the"},{"location":"Part%201/04-Custom-Playbooks/#nginx-application-stack-with-a-customized-indexhtml-file","text":"name: Install nginx hosts: webserver tasks: - name: Add epel-release repo yum: name: epel-release state: present - name: Install nginx yum: name: nginx state: present - name: Insert index page template: src: index.html dest: /usr/share/nginx/html/index.html - name: Start nginx service service: name: nginx state: started ``` Playbook #1 # ANSIBLE PLAYBOOK - Install an nginx webserver and launch the service # AUTHOR \u2014 Deepak C. Shetty (deepakcshetty@in.ibm.com) # # Module makes use of the 'yum' package manager, as well as the # 'template' and 'service' Ansible modulesm for installing the # nginx application stack with a customized index.html file. - name: Install nginx hosts: webserver tasks: - name: Add epel-release repo yum: name: epel-release state: present - name: Install nginx yum: name: nginx state: present - name: Insert index page template: src: index.html dest: /usr/share/nginx/html/index.html - name: Start nginx service service: name: nginx state: started Playbook #2 # ANSIBLE PLAYBOOK \u2014 Invoke 2 modules to automatically update 2 types of servers. # AUTHOR: Red Hat @ https://www.redhat.com/en/topics/automation/what-is-an-ansible-playbook --- # Task 1 - name: Update web servers hosts: webservers become: true tasks: - name: Ensure apache is at the latest version ansible.builtin.yum: name: httpd state: latest - name: Write the apache config file ansible.builtin.template: src: /srv/httpd.j2 dest: /etc/httpd.config mode: \"0644\" # Task 2 - name: Update db servers hosts: databases become: true tasks: - name: Ensure postgresql is at the latest version ansible.builtin.yum: name: postgresql state: latest - name: Ensure that postgresql is started ansible.builtin.service: name: postgresql state: started","title":"nginx application stack with a customized index.html file."},{"location":"Part%201/04-Custom-Playbooks/#_2","text":"","title":""},{"location":"Part%201/04-Custom-Playbooks/#precision-is-key-for-natural-language-prompts","text":"Consider the following Task, which prompts Ansible to create (\"write\") a configuration file for an Apache webserver: - name: Write the apache config file Two tabs are presented below. The first AI-Generated Code tab shows the output from running Ansible Lightspeed's generative AI capabilities on an unmodified version of this Playbook. The second Solution Code tab shows the expected Task code that was written (and commented out) by a human to perform the same task. In theory, the suggested code should be as good\u2014 or even superior to \u2014the manually-written solution code. Let's examine that theory in practice: AI-Generated Code Solution Code - name : Write the apache config file ansible.builtin.copy : content : \"{{ _content_ }}\" dest : /etc/httpd/conf.d/000-default.conf - name : Write the apache config file ansible.builtin.template : src : /srv/httpd.j2 dest : /etc/httpd.config mode : \"0644\" As you can see, the AI-Generated code in the first tab misses the mark in a few areas. In fact, it appears to have misunderstood the task in quite a few ways. There is no corresponding value to _content_ that can be located within the Ansible Playbook, at least not any which you (the author) have defined ahead of time. Such a result is unexpected and does not match the intention of writing an Apache configuration file to standards/best practices. Similarly, the destination has been inferred differently and the access permissions that should have been applied to the config file (again - according to Red Hat best practices) is missing altogether. WHY THE UNEXPECTED RESULTS? Something has gone wrong \u2014 is Ansible Lightspeed at fault? The root cause of the error, in fact, is human . The precision with which the Playbook author describes the automation Task in natural language will determine the accuracy and effectiveness of Ansible Lightspeed's generated code suggestions. In general, the more ambiguous the Task description given, the greater the likelihood that Ansible Lightspeed will misinterpret the author's intent and suggest unwanted Ansible automation jobs. To help disambiguate our intention, we as Playbook authors can use more precise natural language terms and descriptions. Let's slightly modify the Task description (within the - name: line) and observe how the AI-generated code suggestions are modified as a result: AI-Generated Code Solution Code - name : Write the apache config file with mode 0644 ansible.builtin.copy : content : \"{{ _content_ }}\" dest : /etc/httpd/conf.d/000-default.conf - name : Write the apache config file ansible.builtin.copy : content : \"{{ _content_ }}\" dest : /etc/httpd/conf.d/000-default.conf","title":"Precision is key for natural language prompts"}]}